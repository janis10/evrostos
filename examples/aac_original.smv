-- Authoer: Yang Zhao (zhaoy@cs.ucr.edu)
-- This model consists of  modules:
-- * Aircraft: to mimic the behavior of aircraft (pilot). Initially, we assume 
--  the pilot is competant and always corresponds to the commands correctly.
--  And then in future, we can ''inject'' some unexpected behavior of aircraft in 
--  this module and analyze the impact to the whole system.
-- * Controller: A human controller equipped with AutoResolver.
-- * TSAFE : short-range conflict resolution.
-- * TCAS: the last-level to avoid conflict, the command from TCAS must be executed 
--  immediately. 

-- Edit by: Tzanis Anevlavis (janis10@ucla.edu)
-- Code J-Edit for the following changes:
-- 1. Add new definitions in "main" for the rLTL model checking: Line 471.

MODULE Aircraft (CTR_ac_in, TSAFE_ac_in   -- TCAS_command is assigned from environment. 
        -- modes_request_in,
        -- controller_ac_in
)
  VAR 
    CTR_command : boolean;
    CTR_command_done : boolean;
    TSAFE_command : boolean;
    TSAFE_command_done : boolean;
    TCAS_command : boolean;    
    TCAS_command_done : boolean;    

  -- OUTPUT:
  -- Output to TSAFE that a conflict has been solved. So the alert should be released.
  -- In practice this link does not exist, but TSAFE can get it through monitoring.
  -- We make it in this way to avoid some spurious couterexamples.

  INIT
    -- Initially, the airspace is clear and there are no commands or requests.
    CTR_command = FALSE &
    TSAFE_command = FALSE &
    CTR_command_done = FALSE &
    TSAFE_command_done = FALSE &
    TCAS_command_done = FALSE;    
    
  ASSIGN 
    -- The following assignments are assumed to be guaranteed by machine automatically.
    -- Generally speaking, if a command is received from center, set the corresponding 
    -- command value, and when this command is done, reset it;
    next(CTR_command) := 
            case
                !CTR_command & CTR_ac_in : TRUE;
                CTR_command  & CTR_command_done : FALSE;
                TRUE: CTR_command;
                        esac;
    next(TSAFE_command) := 
            case
                !TSAFE_command & TSAFE_ac_in : TRUE;
                TSAFE_command  & TSAFE_command_done : FALSE;
                TRUE: TSAFE_command;
                        esac;

    next(CTR_command_done) :=
            case 
                !TCAS_command & !TSAFE_command & CTR_command : TRUE; 
                TRUE: FALSE;
            esac;
    next(TSAFE_command_done) :=
            case
                !TCAS_command & TSAFE_command : TRUE;
                TRUE: FALSE;
            esac;
    next(TCAS_command_done) :=
            case 
                TCAS_command : TRUE;
                TRUE: FALSE;
            esac;

--  TRANS
--    -- Generally, all 2^4=16 cases needs to be considered, according to what commands 
--    -- are received. But we can use don't care to reduce some equivalent cases.
--    -- We assume that in one time frame, only one thing can be done, so we set one 
--    -- command_done variable, reset all the other variables.
--
--    -- Case 1: TCAS command overrides all.
--       (TCAS_command ->
--      (
--      next(TCAS_command_done)
--      & next(!CTR_command_done) &  next(!TSAFE_command_done)
--      )) &
--       (!TCAS_command -> next(!TCAS_command_done)) &
--
--    -- Case 2: TSAFE command overrides other commands
--       (!TCAS_command & TSAFE_command ->
--      (
--      next(TSAFE_command_done)
--      & next(!TCAS_command_done) & next(!CTR_command_done)) 
--      ) &
--       (!TSAFE_command -> next(!TSAFE_command_done)) &
--    
--    -- Case 3: Cotroller sends request directly to the aircraft -- abstracted out in this version.
--    -- Case 4: In normal case, aircraft always follow CTR
--       (!TCAS_command & !TSAFE_command & CTR_command ->
--      (
--      next(CTR_command_done)
--      & next(!TCAS_command_done) & next(!TSAFE_command_done))  
--      ) & 
--       (!CTR_command -> next(!CTR_command_done) & next(!TCAS_command_done) & next(!TSAFE_command_done))



MODULE TSAFE(
    TSAFE_alert12, TSAFE_alert13, TSAFE_alert23,
    TSAFE_sndcmd_in
    )
  VAR
    -- internal variable, the resolution generated by TSAFE may or
    -- may not be permitted by controller.
    TSAFE_res1 : boolean; 
    TSAFE_res2 : boolean;
    TSAFE_res3 : boolean;

    -- Output to channel connection to aircraft. TSAFE command.
    TSAFE_command1 : boolean; 
    TSAFE_command2 : boolean;
    TSAFE_command3 : boolean;

    
    TSAFE_window : boolean;

    TSAFE_control1 : boolean;
    TSAFE_control2 : boolean;
    TSAFE_control3 : boolean;

  DEFINE
    alert12 := !(TSAFE_alert12 = Non);
    alert23 := !(TSAFE_alert23 = Non);
    alert13 := !(TSAFE_alert13 = Non);
    TSAFE_control := (TSAFE_alert12 = BT) | (TSAFE_alert13 = BT) | (TSAFE_alert23 = BT);

  ASSIGN
    init(TSAFE_window) := FALSE;
    next(TSAFE_window) := case
                TSAFE_window : FALSE;               -- comment out if allow continuous resolution sending.
                TSAFE_window : {FALSE, TRUE};
            TSAFE_control1 | TSAFE_control2 | TSAFE_control3 : {TRUE,FALSE};
            TRUE: FALSE;
            esac;
    
    init(TSAFE_control1) := FALSE;
    next(TSAFE_control1) := case 
                !TSAFE_control1 & ((TSAFE_alert12 != Non) | (TSAFE_alert13 != Non)) & TSAFE_control   : TRUE;
            !TSAFE_control1 & ((TSAFE_alert12 != Non) | (TSAFE_alert13 != Non)) & TSAFE_sndcmd_in : TRUE;
            -- TSAFE_control1 & !(((TSAFE_alert12 != Non) | (TSAFE_alert13 != Non)) & TSAFE_control) : FALSE;
            TSAFE_control1 & ((TSAFE_alert12 = Non) & (TSAFE_alert13 = Non)) : FALSE;
            TRUE: TSAFE_control1;
            esac;
    init(TSAFE_control2) := FALSE;
    next(TSAFE_control2) := case 
                !TSAFE_control2 & ((TSAFE_alert12 != Non) | (TSAFE_alert23 != Non)) & TSAFE_control   : TRUE;
            !TSAFE_control2 & ((TSAFE_alert12 != Non) | (TSAFE_alert23 != Non)) & TSAFE_sndcmd_in : TRUE;
            -- TSAFE_control2 & !(((TSAFE_alert12 != Non) | (TSAFE_alert23 != Non)) & TSAFE_control) : FALSE;
            TSAFE_control2 & ((TSAFE_alert12 = Non) & (TSAFE_alert23 = Non)) : FALSE;
            TRUE: TSAFE_control2;
            esac;
    init(TSAFE_control3) := FALSE;
    next(TSAFE_control3) := case 
                !TSAFE_control3 & ((TSAFE_alert13 != Non) | (TSAFE_alert23 != Non)) & TSAFE_control   : TRUE;
            !TSAFE_control3 & ((TSAFE_alert13 != Non) | (TSAFE_alert23 != Non)) & TSAFE_sndcmd_in : TRUE;
            --TSAFE_control3  & !(((TSAFE_alert13 != Non) | (TSAFE_alert23 != Non)) & TSAFE_control) : FALSE;
            TSAFE_control3  & ((TSAFE_alert13 = Non) & (TSAFE_alert23 = Non)) : FALSE;
            TRUE: TSAFE_control3;
            esac;


    init(TSAFE_command1) := FALSE;
    next(TSAFE_command1) := case
            TSAFE_command1              : FALSE;
            TSAFE_res1 & !TSAFE_control1 & ((TSAFE_alert12 != Non) | (TSAFE_alert13 != Non)) & TSAFE_control   : TRUE;
            TSAFE_res1 & !TSAFE_control1 & ((TSAFE_alert12 != Non) | (TSAFE_alert13 != Non)) & TSAFE_sndcmd_in : TRUE;
                TSAFE_control1 & TSAFE_res1 & TSAFE_window : TRUE;
            TRUE: TSAFE_command1;
        esac;
    init(TSAFE_command2) := FALSE;
    next(TSAFE_command2) := case
            TSAFE_command2              : FALSE;
            TSAFE_res2 & !TSAFE_control2 & ((TSAFE_alert12 != Non) | (TSAFE_alert23 != Non)) & TSAFE_control   : TRUE;
            TSAFE_res2 & !TSAFE_control2 & ((TSAFE_alert12 != Non) | (TSAFE_alert23 != Non)) & TSAFE_sndcmd_in : TRUE;
                TSAFE_control2 & TSAFE_res2 & TSAFE_window : TRUE;
            TRUE: TSAFE_command2;
        esac;
    init(TSAFE_command3) := FALSE;
    next(TSAFE_command3) := case
            TSAFE_command3              : FALSE;
            TSAFE_res3 & !TSAFE_control3 & ((TSAFE_alert13 != Non) | (TSAFE_alert23 != Non)) & TSAFE_control   : TRUE;
            TSAFE_res3 & !TSAFE_control3 & ((TSAFE_alert13 != Non) | (TSAFE_alert23 != Non)) & TSAFE_sndcmd_in : TRUE;
                TSAFE_control3 & TSAFE_res3 & TSAFE_window : TRUE;
            TRUE: TSAFE_command3;
        esac;

  INVAR
  -- Based on the conflict alert, how to sent command.
  -- Mimic the resolution algorithm
      (alert12 -> (TSAFE_res1 | TSAFE_res2))
    & (alert23 -> (TSAFE_res2 | TSAFE_res3))
    & (alert13 -> (TSAFE_res1 | TSAFE_res3))
    & ((!alert13 & !alert12) -> !TSAFE_res1) 
    & ((!alert12 & !alert23) -> !TSAFE_res2) 
    & ((!alert23 & !alert13) -> !TSAFE_res3);
   
  FAIRNESS
   !(((TSAFE_alert12!=Non) | (TSAFE_alert13!=Non) | (TSAFE_alert23!=Non)) & !TSAFE_window);

MODULE Controller(
      ar_conflict_12, ar_conflict_13, ar_conflict_23
--  , ar_command_done1, ar_command_done2, ar_command_done3
    , tsafe_alert_12, tsafe_alert_13, tsafe_alert_23
--  , tsafe_res_1, tsafe_res_2, tsafe_res_3         -- should be whether aircraft is involved in conflict.
    , tsafe_control_in1, tsafe_control_in2, tsafe_control_in3
    )
  VAR
    -- There is in fact only one snd cmd approve for TSAFE: 
    -- send current resolution to all aircraft involved.
    tsafe_sndcmd : boolean;
    
    CTR_command1 : boolean;
    CTR_command2 : boolean;
    CTR_command3 : boolean;

    -- FALSE if it is currently controlled by TSAFE.
    CTR_control_1: boolean;
    CTR_control_2: boolean;
    CTR_control_3: boolean;

    -- resolution, based on current conflicts.
    CTR_res1: boolean;
    CTR_res2: boolean;
    CTR_res3: boolean;

    -- new boolean variable to control the command transition.
    CTR_window: boolean;


  DEFINE
    CTR_control := CTR_control_1 & CTR_control_2 & CTR_control_3;
    controller_choice  := ((tsafe_alert_12!=BT) & (tsafe_alert_13!=BT) & (tsafe_alert_23!=BT)) &
                          ((tsafe_alert_12!=Non) | (tsafe_alert_13!=Non) | (tsafe_alert_23!=Non));

  ASSIGN
    -- Command Transition Window
    init(CTR_window) := FALSE;
    next(CTR_window) := case
                    CTR_window : FALSE;
                ar_conflict_12 | (tsafe_alert_12!=Non) | 
                ar_conflict_13 | (tsafe_alert_13!=Non) | 
                ar_conflict_23 | (tsafe_alert_23!=Non) : {TRUE, FALSE};
                TRUE: CTR_window;
                esac;


    init(CTR_control_1) := TRUE;
    next(CTR_control_1) := case
                    CTR_control_1 & (tsafe_alert_12!=Non | tsafe_alert_13!=Non) & tsafe_sndcmd: FALSE; 
                CTR_control_1 & tsafe_control_in1: FALSE;
                !CTR_control_1 & !tsafe_control_in1: TRUE;
                TRUE: CTR_control_1;
                    esac;
    init(CTR_control_2) := TRUE;
    next(CTR_control_2) := case
                    CTR_control_2 & (tsafe_alert_12!=Non | tsafe_alert_23!=Non) & tsafe_sndcmd: FALSE; 
                CTR_control_2 & tsafe_control_in2: FALSE;
                !CTR_control_2 & !tsafe_control_in2: TRUE;
                TRUE: CTR_control_2;
                    esac;
    init(CTR_control_3) := TRUE;
    next(CTR_control_3) := case
                    CTR_control_3 & (tsafe_alert_23!=Non | tsafe_alert_13!=Non) & tsafe_sndcmd: FALSE; 
                CTR_control_3 & tsafe_control_in3: FALSE;
                !CTR_control_3 & !tsafe_control_in3: TRUE;
                TRUE: CTR_control_3;
                    esac;
    
    init(tsafe_sndcmd) := FALSE;
    next(tsafe_sndcmd) := case
                (!tsafe_sndcmd) & CTR_control & controller_choice : {FALSE, TRUE};  
                TRUE: FALSE;
                esac;

    init(CTR_command1) := FALSE;
    next(CTR_command1) := case 
                !CTR_control_1 : FALSE;
            CTR_res1 & CTR_window : TRUE;
            CTR_command1 : FALSE;
            TRUE: CTR_command1;
            esac;
    init(CTR_command2) := FALSE;
    next(CTR_command2) := case 
                !CTR_control_2 : FALSE;
            CTR_res2 & CTR_window : TRUE;
            CTR_command2 : FALSE;
            TRUE: CTR_command2;
            esac;
    init(CTR_command3) := FALSE;
    next(CTR_command3) := case 
                !CTR_control_3 : FALSE;
            CTR_res3 & CTR_window : TRUE;
            CTR_command3 : FALSE;
            TRUE: CTR_command3;
            esac;

  -- Auto-resolver will not generate 
  INVAR 
    (CTR_res1 -> (ar_conflict_12 | ar_conflict_13 | tsafe_alert_12 != Non | tsafe_alert_13 != Non))
    &
    (CTR_res2 -> (ar_conflict_12 | ar_conflict_23 | tsafe_alert_12 != Non | tsafe_alert_23 != Non))
    &
    (CTR_res3 -> (ar_conflict_13 | ar_conflict_23 | tsafe_alert_13 != Non | tsafe_alert_23 != Non))
    & 
    (tsafe_sndcmd -> (!CTR_res1 & !CTR_res2 & !CTR_res3));

--    !(CTR_res1 & !(ar_conflict_12 | ar_conflict_13 | tsafe_alert_12 != Non | tsafe_alert_13 != Non))
--    &
--    !(CTR_res2 & !(ar_conflict_12 | ar_conflict_23 | tsafe_alert_12 != Non | tsafe_alert_23 != Non))
--    &
--    !(CTR_res3 & !(ar_conflict_13 | ar_conflict_23 | tsafe_alert_13 != Non | tsafe_alert_23 != Non))
--    &
--    !(tsafe_sndcmd & (CTR_res1 | CTR_res2 | CTR_res3));


  FAIRNESS
   !((ar_conflict_12 | (tsafe_alert_12!=Non) | ar_conflict_13 | (tsafe_alert_13!=Non) | ar_conflict_23 | (tsafe_alert_23!=Non)) & !CTR_window);

-- All the inputs are designed to model the causual relationship 
-- between the executions of manoeuvres and the new conflicts.
MODULE Environment (
      CTR_command_done1, CTR_command_done2, CTR_command_done3
    , TCAS_command1, TCAS_command2, TCAS_command3
    , TCAS_command_done1, TCAS_command_done2, TCAS_command_done3
    , TSAFE_command_done1, TSAFE_command_done2, TSAFE_command_done3
)

  VAR
    -- variables indicating strategic-level (for auto-resolver) conflicts in pairs.
    ar_conflict_12 : boolean;
    ar_conflict_23 : boolean;
    ar_conflict_13 : boolean;

    -- variables indicating tactical-level (for TSAFE) conflicts.
    -- There are three values for these variables: 
    -- * Non: None alert
    -- * AT : Time to the loss of seperation is above the threshold
    -- * BT : Time to the loss of seperation is below the threshold
    tsafe_alert_12 : {Non, AT, BT};
    tsafe_alert_23 : {Non, AT, BT};
    tsafe_alert_13 : {Non, AT, BT};
  
  -- It is necessary to constrain the fact variables, or it will produce lots meaningless
  -- counterexample. Rules are following.

  -- R1: only one of tsafe_alert12 and ar_conflict_12 is 1 in a time frame, so are other 
  --     pairs of tsafe and ar conflict pairs. It is based on simple 
  -- R2: TSAFE(CTR, TCAS)_command_done1 will reset the tsafe_alert12
  -- R3: Based on AIAA'08 paper by Tang, what is the relationship between TSAFE and TCAS?
  
  -- optimistic case, any aircraft maneuver done will resolve all pairs of conflicts
  -- involving this aircraft
  INVAR
    -- ar_conflict and tsafe_alert for the same pair of aircraft
    -- will not occur at the same time.
      !(ar_conflict_12 & tsafe_alert_12 != Non) 
    & !(ar_conflict_13 & tsafe_alert_13 != Non)
    & !(ar_conflict_23 & tsafe_alert_23 != Non)
    -- only one ar_conflict will occur at the same time.
    & !(ar_conflict_12 & ar_conflict_13)
    & !(ar_conflict_12 & ar_conflict_23)
    & !(ar_conflict_13 & ar_conflict_23)
    ;

  ASSIGN
    -- CTR alert generation.
    init(ar_conflict_12) := FALSE;
    next(ar_conflict_12) := case
        -- This order really matters!
        !ar_conflict_12 : {FALSE, TRUE};
        ar_conflict_12 & (CTR_command_done1 | CTR_command_done2) : FALSE;
            TRUE: ar_conflict_12;
            esac;
    init(ar_conflict_13) := FALSE;
    next(ar_conflict_13) := case
        !ar_conflict_13 : {FALSE, TRUE};
        ar_conflict_13 & (CTR_command_done1 | CTR_command_done3) : FALSE;
            TRUE: ar_conflict_13;
            esac;
    init(ar_conflict_23) := FALSE;
    next(ar_conflict_23) := case
        !ar_conflict_23 : {FALSE, TRUE};
        ar_conflict_23 & (CTR_command_done3 | CTR_command_done2) : FALSE;
            TRUE: ar_conflict_23;
            esac;

    -- TSAFE alert generation.
    init(tsafe_alert_12) := Non;
    next(tsafe_alert_12) := case
            -- This order really matters!
        tsafe_alert_12 = Non & !TSAFE_command_done1 & !TSAFE_command_done2 : {Non, AT, BT};
        !(tsafe_alert_12 = Non) & (TSAFE_command_done1 | TSAFE_command_done2) : Non;
        tsafe_alert_12 = AT  : {AT, BT};
            TRUE: tsafe_alert_12;
            esac;

    init(tsafe_alert_13) := Non;
    next(tsafe_alert_13) := case
            tsafe_alert_13 = Non & !TSAFE_command_done1 & !TSAFE_command_done3 : {Non, AT, BT};
        !(tsafe_alert_13 = Non) & (TSAFE_command_done1 | TSAFE_command_done3) : Non;
        tsafe_alert_13 = AT  : {AT, BT};
            TRUE: tsafe_alert_13;
            esac;

    init(tsafe_alert_23) := Non;
    next(tsafe_alert_23) := case
            tsafe_alert_23 = Non & !TSAFE_command_done3 & !TSAFE_command_done2 : {Non, AT, BT};
        !(tsafe_alert_23 = Non) & (TSAFE_command_done2 | TSAFE_command_done3) : Non;
        tsafe_alert_23 = AT  : {AT, BT};
            TRUE: tsafe_alert_23;
            esac;
    
    next(TCAS_command1) :=
            case 
                -- TCAS command is done, then reset the variable.
                TCAS_command1 & TCAS_command_done1 : FALSE;
                -- TCAS command is not done, always set this variable.
                TCAS_command1 & !TCAS_command_done1 : TRUE;
                -- else, randomly generate TCAS_command.
                !TCAS_command1 : {TRUE, FALSE};
            TRUE: TCAS_command1;
            esac;
    
    next(TCAS_command2) :=
            case 
                TCAS_command2 & TCAS_command_done2 : FALSE;
                TCAS_command2 & !TCAS_command_done2 : TRUE;
                !TCAS_command2 : {TRUE, FALSE};
            TRUE: TCAS_command2;
            esac;

    next(TCAS_command3) :=
            case 
                TCAS_command3 & TCAS_command_done3 : FALSE;
                TCAS_command3 & !TCAS_command_done3 : TRUE;
                !TCAS_command3 : {TRUE, FALSE};
            TRUE: TCAS_command3;
            esac;
--  FAIRNESS
--    (tsafe_alert_12 != AT) & (tsafe_alert_23 != AT) & (tsafe_alert_13 != AT);
--  
--  FAIRNESS
--    (tsafe_alert_12 = Non) & (tsafe_alert_23 = Non) & (tsafe_alert_13 = Non);

  FAIRNESS
    (tsafe_alert_12 != AT);
  FAIRNESS
    (tsafe_alert_23 != AT);
  FAIRNESS
    (tsafe_alert_13 != AT);

MODULE main
  DEFINE
    ar_ac_in1 := controller.CTR_command1;
    ar_ac_in2 := controller.CTR_command2;
    ar_ac_in3 := controller.CTR_command3;

    tsafe_ac_in1 := tsafe.TSAFE_command1;
    tsafe_ac_in2 := tsafe.TSAFE_command2;
    tsafe_ac_in3 := tsafe.TSAFE_command3;

-------------------------------------------------------------------------------
-------------------- J-edit: Definitions for rLTL formulas --------------------
-------------------------------------------------------------------------------
    ctr0 := controller.CTR_control;
    ctr1 := controller.CTR_control_1;
    --ctr2 := controller.CTR_control_2;
    --ctr3 := controller.CTR_control_3;
    tsscmd := controller.tsafe_sndcmd;

    ta12bt := env.tsafe_alert_12 = BT;
    --ta13bt := env.tsafe_alert_13 = BT;
    --ta23bt := env.tsafe_alert_23 = BT;
    ta12non := env.tsafe_alert_12 = Non;
    ta13non := env.tsafe_alert_13 = Non;
    ta23non := env.tsafe_alert_23 = Non;
    ta12at := env.tsafe_alert_12 = AT;
    ta13at := env.tsafe_alert_13 = AT;
    ta23at := env.tsafe_alert_23 = AT;

    tswin := tsafe.TSAFE_window;
    tscmd1 := tsafe.TSAFE_command1;
    tscmd2 := tsafe.TSAFE_command2;
    --tscmd3 := tsafe.TSAFE_command3;

    tsctr1 := tsafe.TSAFE_control1;
    --tsctr2 := tsafe.TSAFE_control2;
    --tsctr3 := tsafe.TSAFE_control3;

    ac1tscmd := ac1.TSAFE_command;
    ac2tscmd := ac2.TSAFE_command;
    --ac3tscmd := ac3.TSAFE_command;

    ac1tscmddone := ac1.TSAFE_command_done;
    ac2tscmddone := ac2.TSAFE_command_done;
    --ac3tscmddone := ac3.TSAFE_command_done;

    ac1tccmd := ac1.TCAS_command;
    --ac2tccmd := ac2.TCAS_command;
    --ac3tccmd := ac3.TCAS_command;

    ac1tccmddone := ac1.TCAS_command_done;
    --ac2tccmddone := ac2.TCAS_command_done;
    --ac3tccmddone := ac3.TCAS_command_done;

    ac1ctrcmddone := ac1.CTR_command_done;
    --ac2ctrcmddone := ac2.CTR_command_done;
    --ac3ctrcmddone := ac3.CTR_command_done;
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

  VAR
    ac1 : Aircraft (ar_ac_in1 , tsafe_ac_in1);   
    ac2 : Aircraft (ar_ac_in2 , tsafe_ac_in2);  
    ac3 : Aircraft (ar_ac_in3 , tsafe_ac_in3);  

    env : Environment (
      ac1.CTR_command_done, ac2.CTR_command_done, ac3.CTR_command_done
    , ac1.TCAS_command, ac2.TCAS_command, ac3.TCAS_command
    , ac1.TCAS_command_done, ac2.TCAS_command_done, ac3.TCAS_command_done
    , ac1.TSAFE_command_done, ac2.TSAFE_command_done, ac3.TSAFE_command_done
        );

    tsafe : TSAFE(
    env.tsafe_alert_12, env.tsafe_alert_13, env.tsafe_alert_23,
    controller.tsafe_sndcmd
    );

    controller : Controller(
          env.ar_conflict_12, env.ar_conflict_13, env.ar_conflict_23,
--    ac1.CTR_command_done, ac2.CTR_command_done, ac3.CTR_command_done,
      env.tsafe_alert_12, env.tsafe_alert_13, env.tsafe_alert_23,
--        tsafe.TSAFE_res1, tsafe.TSAFE_res2, tsafe.TSAFE_res3,
      tsafe.TSAFE_control1, tsafe.TSAFE_control2, tsafe.TSAFE_control3
    );

--**************************************************